#pragma once
#include "DB.h"
#include "render-preprocessor.h"
#include "node-placer.h"
#include <unordered_map>
#include <vector>

using namespace mftb;

/*
*  Cluster, generated by some couple, consists of all direct descendants 
*  and ancestors of this couple (primary people) and the partners of this
*  people with NO PARENTS SPECIFIED (secondary people).
*
*  If primary person's partner has parents specified, this partner with their 
*  parents generates a new cluster.
*/


enum class RenderMode{
  Extended,
  Compact
};

class FamilyTreeCluster {
public:
  using node = DescendantsNodePlacer::node;
  
  struct person_data {
    bool is_secondary_to_this_cluster = false;
    bool processed = false;
    double x = 0;
    int couple_counter = 0;
  };
  struct couple_data{
    int family_line_y_bias = 1;
    double family_line_connection_point_x;
    bool processed = false;
  };
  struct cluster_candidate{
    bool only_second_partner;
    int generation;
    id_t couple_id;
  };

  using placement_data = std::pair<const std::unordered_map<id_t, person_data>&,
           const std::unordered_map<id_t, couple_data>&>;


public:
  static FamilyTreeCluster
  fromCouple(DB *db, const RenderPreprocessor::data &data, id_t id);

  static FamilyTreeCluster
  fromSecondPartner(DB* db, const RenderPreprocessor::data& data, id_t);

  placement_data getPlacementData();

  std::vector<cluster_candidate> getClusterCandidates();



private:
  const RenderPreprocessor::data &preprocessor_data;
  std::unordered_map<id_t, person_data> persons_placement;
  std::unordered_map<id_t, couple_data> couple_placement;
  std::vector<cluster_candidate> cluster_candidates;

  double leftmost_x = 0, rightmost_x = 0;

  // TODO : think about this kostyl`
  std::pair<int, int> last_placement_borders;
  id_t last_processed_couple = 0;

  mftb::DB *const db;

  RenderMode render_mode;
  
private:

  FamilyTreeCluster(mftb::DB *db_,
                    const RenderPreprocessor::data &data);
  void place_couple_descendants(id_t);
  void place_persons_ancestors(id_t id, double left_border, id_t ignored_partner);

   std::pair<int, int> getPlacementBorders(id_t id);
   std::vector<node> getLowerNodes(node couple_id);
   std::vector<id_t> processPartnersWithNoParents(id_t);

   double place_person(id_t person, double pos);

};
