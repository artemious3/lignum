#pragma once
#include "DB.h"
#include "render-preprocessor.h"
#include <optional>
#include <set>
#include <unordered_map>
#include <vector>

using namespace mftb;

/*
*  Cluster, generated by some couple, consists of all direct descendants 
*  and ancestors of this couple (primary people) and the partners of this
*  people with NO PARENTS SPECIFIED (secondary people).
*
*  If primary person's partner has parents specified, couple of their parents 
*  generates a new cluster.
*/
class FamilyTreeCluster {
public:

  struct person_data {
    bool is_secondary_to_this_cluster = false;
    bool processed = false;
    double x = 0;
    int couple_counter = 0;
  };

  struct couple_data{
    int family_line_y_bias = 1;
    double family_line_connection_point_x;
    bool processed = false;
  };


  struct node{
    id_t primary_person;
    std::optional<id_t> couple_id;
  };

public:
  static FamilyTreeCluster
  fromCouple(DB *db, const RenderPreprocessor::data &data, id_t id);

  std::pair<const std::unordered_map<id_t, person_data>&,
           const std::unordered_map<id_t, couple_data>&> getPlacementData();


private:
  std::unordered_map<id_t, person_data> persons_placement;
  std::unordered_map<id_t, couple_data> couple_placement;

  std::set<id_t> new_cluster_candidates;
  int left_x = 0, right_x = 0;

  // TODO : think about this kostyl`
  std::pair<int, int> last_placement_borders;
  id_t last_processed_couple = 0;


  mftb::DB *const db;
  const RenderPreprocessor::data &preprocessor_data;

private:
  FamilyTreeCluster(mftb::DB *db_,
                    const RenderPreprocessor::data &data);
  void place_descendants(id_t);
  void place_ancestors(id_t);


  std::pair<int, int> getPlacementBorders(id_t id);
   std::vector<node> getLowerNodes(node couple_id);
   std::vector<id_t> processPartnersWithNoParents(id_t);

   double place_person(id_t person, double pos);

};